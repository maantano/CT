# 구간의 합
# 합 배열을 이용하여 시간 복잡도를 더 줄이기 위해 사용하는 특수한 목적의 알고리즘 입니다.

# 구간 합의 핵심 이론
#  구간 합 알고리즘을 활용하려면 먼저 합 배열을 구해야한다. 리스트 A가 있을 때 합 배열 S는 다음과 같이 정의한다.
#  S[i] = A[0] + A[1] + A[2] + ... + A[i-1] + A[i] --  A[0]부터  A[i]까지의 합
#
#  합 배열은 기존의 리스트 데이터를 전처리한 배열이라고 생각하면 된다. 
# 이렇게 합 배열을 미리 구해 놓으면 기존 리스트의 일정 범위의 합을 구하는 시간 복잡도가 O(N)에서 O(1)로 감소 한다.

# 합 배열 ex.
#          0   1   2  3  4   5
# 리스트 A [15, 13, 10, 7, 3, 12]
# 합 배열 S[15, 28, 38, 45, 48, 60]

# A[i]부터 A[j] 까지의 리스트 합을 합 배열 없이 구하는 경우, 최악의 경우는 i 가 0 이고 j가 N인 경우로 시간 복잡도는 O(N)이다.
# 이런 경우 앞에서 알아본 합 배열을 사용하면 O(1) 안에 답을 구할수 있다. 합 배열은 다음과 같은 간단한 공식으로 만들 수 있다.

# 합 배열 S를 만드는 공식 : S[i] = S[i-1] + A[i]
# 이렇게 구현된 합 배열을 이용하여 구간 합 역시 쉽게 구할 수 있습니다. i에서 j까지 구간 합을 구하는 공식은 다음과 같다.

# i에서 부터 j 까지 구간 합 : S[j] - S[i-1]
# --------------------------------------------------------------------------------------------------------------

# 11659번

# 구간 합 구하기 1

# 입력 예제

# 5 3 / 데이터의 개수, 질문 개수
# 5 4 3 2 1 / 구간 합을 구할 대상 배열

# 1 3
# 2 4
# 5 5

# 1번째 줄에 수의 개수 N, 합을 구해야하는 횟수 M
# 2번째 줄에 N개의 수가 주어진다.
# 3번째 줄부터는 M개의 줄에 합을 구해야하는 구간 i 와 j가 주어진다.


import sys
input = sys.stdin.readline
suNo,quizNo = map(int,input().split())
numbers = map(int,input().split())
prefix_sum = [0]
temp=0

# sum = sum(numbers)

# 구간합 리스트 구하는 소스
for i in numbers:
    temp = temp+i
    prefix_sum.append(temp)
    print(prefix_sum)

for i in range(quizNo):
    s,e = map(int, input().split())
    print(prefix_sum[e] - prefix_sum[s-1])




"""
Key.

    입력 받는 방법 (여러줄 입력받는 상황에서는 반드시 sys.stdin.readline()을 사용해야 시간초과가 발생하지 않는다)
    input = sys.stdin.readline
    suNo,quizNo = map(int,input().split())
    
    📌한 개의 정수를 입력받을 때
        import sys
        a = int(sys.stdin.readline())
        😨 그냥 a = sys.stdin.readline() 하면 안되나요?
        👉 sys.stdin.readline()은 한줄 단위로 입력받기 때문에, 개행문자가 같이 입력 받아집니다.
        만약 3을 입력했다면, 3\n 이 저장되기 때문에, 개행문자를 제거해야 합니다.
        또한, 변수 타입이 문자열 형태(str)로 저장되기 때문에, 정수로 사용하기 위해서 형변환을 거쳐야 합니다.

    
    prefix_sum = [0] 는 리스트 선언한것 일뿐

    먼저 첫번째 for 문으로 구간합 리스트를 만들고 나서
    두번째 for문에서 구간별 리스트 합 계산 공식을 사용 

    prefix_sum.append(temp) 이거는 뒤에 붙인다는 말이기 때문에 실질적으로 반복문이 다 돌고나면 [0, 5, 9, 12, 14, 15] 이렇게 리스트가 만들어지고
    두번째 for문에서 print(prefix_sum[e] - prefix_sum[s-1])는 인덱스 관계 없이 받은 숫자 그대로를 사용함

    
    1번 => S[3] - S[0] => 12 - 0 = 12
    2번 => S[4] - S[1] => 14 - 5 = 0
    3번 => S[5] - S[4] => 15 - 14 = 0
    

슈도 코드
    suNo(숫자,개수)
    quizNo(질문 개수)
    prefix_sum 합 배열 선언
    temp 변수 선언

    for 저장한 숫자 데이터 차례대로 탐색(더함):
        temp에 현재 숫자 데이터 더해 주기
        합 배열에 temp값 저장
    for 질의 개수만큼 반복:
        질의 범위 받기(s~e)
        구간 합 출력 하기(prefix_sum[e]-prefix_sum[s-1])
"""

